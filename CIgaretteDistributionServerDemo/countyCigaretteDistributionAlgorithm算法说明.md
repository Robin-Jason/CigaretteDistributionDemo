### countyCigaretteDistributionAlgorithm 算法说明

#### 1. 数学模型
该算法解决的是一个带约束的优化问题。其核心目标是：在给定预投放总量（TargetAmount）的条件下，为多个区域（Regions）的30个档位（Grades）分配一个最优的卷烟投放数量，使得最终的“实际投放量”与“预投放量”之间的误差最小。

- **变量定义**:
   - 设共有 \\( R \\) 个投放区域和 \\( B=30 \\) 个档位（从 D30 到 D1）。
   - \\( c_{ij} \\)：表示区域 \\( i \\) 在档位 \\( j \\) 的客户数量。这是一个已知矩阵。
   - \\( x_{ij} \\)：**待求变量**，表示分配给区域 \\( i \\) 档位 \\( j \\) 的卷烟包数，\\( x_{ij} \\) 必须为非负整数。
   - \\( T \\)：预设的总投放量（TargetAmount）。

- **目标函数**:
  最小化误差 \\( E \\)，即实际投放量 \\( S \\) 与预投放量 \\( T \\) 的绝对差值：
  $$\min E = \left| S - T \right| = \left| \left( \sum_{i=1}^{R} \sum_{j=1}^{B} x_{ij} \cdot c_{ij} \right) - T \right|$$

- **核心约束条件 (非递增约束)**:
  对于任何一个区域 \\( i \\)，其从高档位到低档位（即从 D30 到 D1）的分配数量必须是非递增的。也就是说，分配给更高档位的数量不能少于分配给更低档位的数量：
  $$x_{i,j} \geq x_{i,j+1} \quad \forall i \in [1, R], \forall j \in [1, B-1]$$
  这个约束确保了投放策略的合理性，即高档位客户的满足度不应低于低档位客户。

#### 2. 算法描述
该算法采用了一种“贪心填充 + 迭代微调”的启发式策略来求解上述优化问题。它不保证找到全局最优解，但旨在高效地找到一个高质量的近似解。

**算法主要分为三个阶段：**

1.  **初始贪心填充 (`greedyFill` 方法)**
   - **目标**: 快速构建一个满足非递增约束且总投放量不超过预设目标的基础解。
   - **步骤**:
      1.  初始化一个全为0的分配矩阵 \\( X \\)。
      2.  从最高档位（D30）开始，逐一遍历所有区域的所有档位。
      3.  在每个位置 \\( (i, j) \\)，检查如果将 \\( x_{ij} \\) 增加1，是否会违反非递增约束 (即 \\( x_{ij}+1 \leq x_{i,j-1} \\))。
      4.  如果约束满足，并且增加后的总投放量 \\( S \\) 不会超过预设目标 \\( T \\)，则将 \\( x_{ij} \\) 加1，并更新当前总投放量 \\( S \\)。
      5.  重复此过程，直到无法再增加任何位置的分配值（因为再增加就会超过 \\( T \\)），贪心阶段结束。
   - **特点**: 此阶段构建的解非常“靠前”，即分配值集中在高档位，且与目标值有一定差距。

2.  **迭代微调 (`iterativeRefinement` 方法)**
   - **目标**: 在贪心填充的基础上，通过小步长的调整来逐步减小误差 \\( |S - T| \\)。
   - **步骤**:
      1.  设定最大迭代次数（`MAX_ITERATIONS = 100`）。
      2.  在每次迭代中，遍历分配矩阵 \\( X \\) 的每一个元素 \\( x_{ij} \\)。
      3.  对每个 \\( x_{ij} \\)，尝试两种操作：**增加1** 或 **减少1**。
      4.  对于每一种尝试的操作，检查操作后的新矩阵是否仍然满足完整的非递增约束。
      5.  如果满足约束，则计算新的总投放量和新的误差。
      6.  在所有可能的“增一”或“减一”操作中，找到那个能使误差变得最小的操作，并记录下是哪个位置（`best_i`, `best_j`）和哪种变化（`best_change`）。
      7.  将本次迭代找到的最佳操作应用到分配矩阵上，更新当前误差。
      8.  如果一轮迭代下来没有找到任何可以减小误差的操作，则提前终止迭代。
   - **特点**: 这是一个局部搜索过程，通过反复的、细微的调整来优化解的质量，使其更接近目标投放量。

3.  **最终强制约束 (`enforceMonotonicConstraint` 方法)**
   - **目标**: 作为最后一道保险，确保最终输出的分配矩阵严格满足非递增约束。
   - **步骤**:
      1.  遍历每个区域的分配方案（矩阵的每一行）。
      2.  从第二个档位（D29）开始，检查其值 \\( x_{ij} \\) 是否大于前一个更高档位的值 \\( x_{i,j-1} \\)。
      3.  如果 \\( x_{ij} > x_{i,j-1} \\)，则强制将 \\( x_{ij} \\) 的值修正为 \\( x_{i,j-1} \\)，以确保非递增。
   - **特点**: 这是一个校正步骤，虽然迭代微调过程已考虑了约束，但此步骤能修复任何可能因算法逻辑不完美而产生的微小违反。