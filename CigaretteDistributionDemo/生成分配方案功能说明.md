# 生成分配方案功能说明

## 📋 功能概述

新增了生成分配方案功能，用户可以选择指定的年、月、周序号，系统将自动根据卷烟投放基本信息和区域客户数据生成各卷烟的档位分配方案。

### 🎯 核心功能特性

1. **时间选择** ✅ - 支持选择年份、月份、周序号
2. **智能生成** ✅ - 基于投放基本信息和客户数据自动计算
3. **批量处理** ✅ - 一次性处理选定时间范围内的所有卷烟
4. **结果反馈** ✅ - 显示处理成功的卷烟记录数量
5. **数据刷新** ✅ - 生成后自动刷新表格显示最新数据

---

## 🎨 前端界面设计

### 1. 生成分配方案按钮

```vue
<el-button 
  type="warning" 
  size="default"
  @click="showGeneratePlanDialog"
>
  <el-icon><Cpu /></el-icon>
  生成分配方案
</el-button>
```

**按钮特点**：
- 位置：在"导入区域客户数"按钮后面
- 样式：警告色（橙色），突出重要性
- 图标：CPU图标，表示计算处理功能

### 2. 生成分配方案对话框

```vue
<el-dialog
  v-model="generatePlanDialogVisible"
  title="生成分配方案"
  width="500px"
  :close-on-click-modal="false"
>
  <!-- 功能说明 -->
  <el-alert title="分配方案生成说明" type="info">
    <p>系统将根据选定时间的卷烟投放基本信息和区域客户数据，自动计算生成各卷烟的档位分配方案。</p>
    <p>请选择需要生成分配方案的时间范围：</p>
  </el-alert>
  
  <!-- 时间选择表单 -->
  <el-form :model="generatePlanForm" label-width="80px">
    <el-form-item label="年份" required>
      <el-select v-model="generatePlanForm.year">
        <!-- 年份选项 -->
      </el-select>
    </el-form-item>
    
    <el-form-item label="月份" required>
      <el-select v-model="generatePlanForm.month">
        <!-- 月份选项 -->
      </el-select>
    </el-form-item>
    
    <el-form-item label="周序号" required>
      <el-select v-model="generatePlanForm.weekSeq">
        <!-- 周序号选项 -->
      </el-select>
    </el-form-item>
  </el-form>
  
  <!-- 状态提示 -->
  <el-alert v-if="!isGeneratePlanTimeComplete" 
    title="请选择完整的时间信息后再生成分配方案" 
    type="warning" />
  <el-alert v-else 
    :title="`将为 ${generatePlanForm.year}年${generatePlanForm.month}月第${generatePlanForm.weekSeq}周 生成分配方案`" 
    type="success" />
</el-dialog>
```

### 3. 智能状态管理

#### 3.1 数据属性
```javascript
data() {
  return {
    // 生成分配方案
    generatePlanDialogVisible: false,
    generatePlanForm: {
      year: null,
      month: null,
      weekSeq: null
    },
    generatingPlan: false
  }
}
```

#### 3.2 计算属性
```javascript
computed: {
  // 生成分配方案时间表单是否完整
  isGeneratePlanTimeComplete() {
    return this.generatePlanForm.year && 
           this.generatePlanForm.month && 
           this.generatePlanForm.weekSeq
  },
  
  // 是否可以生成分配方案
  canGeneratePlan() {
    return this.isGeneratePlanTimeComplete && !this.generatingPlan
  }
}
```

---

## 🔧 前端技术实现

### 1. 生成分配方案逻辑

```javascript
async handleGeneratePlan() {
  if (!this.canGeneratePlan) {
    ElMessage.warning('请选择年份、月份和周序号')
    return
  }
  
  this.generatingPlan = true
  
  try {
    const requestData = {
      year: this.generatePlanForm.year,
      month: this.generatePlanForm.month,
      weekSeq: this.generatePlanForm.weekSeq
    }
    
    console.log('生成分配方案请求数据:', requestData)
    
    // 调用后端生成分配方案接口
    const response = await cigaretteDistributionAPI.generateDistributionPlan(requestData)
    
    if (response.data.success) {
      ElMessage.success({
        message: `分配方案生成成功！共处理 ${response.data.processedCount || 0} 条卷烟记录`,
        duration: 3000
      })
      
      // 关闭对话框并清理表单
      this.generatePlanDialogVisible = false
      this.generatePlanForm = { year: null, month: null, weekSeq: null }
      
      // 刷新表格数据
      if (this.$refs.dataTable) {
        this.$refs.dataTable.handleRefresh()
      }
    } else {
      throw new Error(response.data.message || '生成分配方案失败')
    }
  } catch (error) {
    console.error('生成分配方案失败:', error)
    ElMessage.error(`生成失败: ${error.message}`)
  } finally {
    this.generatingPlan = false
  }
}
```

### 2. 用户体验设计

#### 2.1 渐进式操作流程
1. **点击生成分配方案按钮** → 打开时间选择对话框
2. **选择年、月、周序号** → 实时验证表单完整性
3. **智能状态提示** → 显示将要处理的时间范围
4. **确认生成** → 调用后端API进行计算
5. **结果反馈** → 显示处理结果并自动刷新表格

#### 2.2 状态反馈机制
- ✅ **实时验证**：表单完整性实时检查
- ✅ **加载状态**：生成过程中显示"生成中..."
- ✅ **成功反馈**：显示处理的卷烟记录数量
- ✅ **错误处理**：友好的错误提示信息

---

## 🌐 后端接口设计

### 接口概述

**接口地址**: `POST /api/cigarette/generate-distribution-plan`  
**功能描述**: 根据指定时间的卷烟投放基本信息和区域客户数据，自动生成分配方案
**接口类型**: 业务处理接口

### 请求参数

#### 请求体 (JSON)
```json
{
  "year": 2024,
  "month": 1,
  "weekSeq": 1
}
```

#### 参数说明

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| year | Integer | 是 | 年份，用于确定处理的时间范围 |
| month | Integer | 是 | 月份（1-12），用于确定处理的时间范围 |
| weekSeq | Integer | 是 | 周序号（1-5），用于确定处理的时间范围 |

### 响应数据

#### 成功响应示例
```json
{
  "success": true,
  "message": "分配方案生成成功",
  "processedCount": 25,
  "generatedPlans": [
    {
      "cigCode": "42010114",
      "cigName": "红金龙(硬爱你爆珠)",
      "deliveryArea": "城区",
      "distribution": [50.00, 45.00, 40.00, /* ... 30个档位值 */]
    }
    // ... 更多卷烟分配方案
  ],
  "timestamp": "2025-01-09T10:30:00Z"
}
```

#### 失败响应示例
```json
{
  "success": false,
  "message": "生成分配方案失败：缺少基础数据",
  "error": "MISSING_BASE_DATA",
  "details": {
    "missingCigarettes": ["42010115", "42010116"],
    "missingCustomerData": ["城区", "农村"]
  }
}
```

#### 响应字段说明

| 字段名 | 类型 | 说明 |
|--------|------|------|
| success | Boolean | 操作是否成功 |
| message | String | 操作结果消息 |
| processedCount | Integer | 成功处理的卷烟记录数量 |
| generatedPlans | Array&lt;Object&gt; | 生成的分配方案详情 |
| timestamp | String | 生成时间戳 |
| error | String | 错误代码（失败时） |
| details | Object | 错误详情（失败时） |

---

## 💻 后端实现建议

### 1. 业务逻辑流程

```java
@PostMapping("/generate-distribution-plan")
public ResponseEntity<Map<String, Object>> generateDistributionPlan(@RequestBody GeneratePlanRequest request) {
    Map<String, Object> response = new HashMap<>();
    
    try {
        // 1. 验证请求参数
        if (!validateGeneratePlanRequest(request)) {
            response.put("success", false);
            response.put("message", "请求参数无效");
            return ResponseEntity.badRequest().body(response);
        }
        
        // 2. 获取指定时间的卷烟投放基本信息
        List<CigaretteBasicInfo> basicInfoList = getBasicInfoByTime(
            request.getYear(), 
            request.getMonth(), 
            request.getWeekSeq()
        );
        
        if (basicInfoList.isEmpty()) {
            response.put("success", false);
            response.put("message", "指定时间范围内没有卷烟投放基本信息");
            response.put("error", "NO_BASIC_INFO");
            return ResponseEntity.badRequest().body(response);
        }
        
        // 3. 获取区域客户数据
        Map<String, CustomerData> customerDataMap = getCustomerDataByTime(
            request.getYear(), 
            request.getMonth(), 
            request.getWeekSeq()
        );
        
        // 4. 执行分配方案生成算法
        List<DistributionPlan> generatedPlans = new ArrayList<>();
        int processedCount = 0;
        
        for (CigaretteBasicInfo basicInfo : basicInfoList) {
            try {
                // 调用分配算法
                DistributionPlan plan = distributionAlgorithm.generate(basicInfo, customerDataMap);
                
                // 保存到数据库
                if (saveDistributionPlan(plan)) {
                    generatedPlans.add(plan);
                    processedCount++;
                }
            } catch (Exception e) {
                logger.warn("生成卷烟 {} 的分配方案失败: {}", basicInfo.getCigCode(), e.getMessage());
            }
        }
        
        // 5. 返回成功响应
        response.put("success", true);
        response.put("message", "分配方案生成成功");
        response.put("processedCount", processedCount);
        response.put("generatedPlans", convertToResponseFormat(generatedPlans));
        response.put("timestamp", Instant.now().toString());
        
        return ResponseEntity.ok(response);
        
    } catch (Exception e) {
        logger.error("生成分配方案失败", e);
        response.put("success", false);
        response.put("message", "生成失败：" + e.getMessage());
        return ResponseEntity.status(500).body(response);
    }
}
```

### 2. 核心算法模块

#### 2.1 分配算法接口
```java
public interface DistributionAlgorithm {
    /**
     * 生成分配方案
     * @param basicInfo 卷烟基本信息
     * @param customerDataMap 客户数据映射
     * @return 分配方案
     */
    DistributionPlan generate(CigaretteBasicInfo basicInfo, Map<String, CustomerData> customerDataMap);
}
```

#### 2.2 算法实现示例
```java
@Component
public class DefaultDistributionAlgorithm implements DistributionAlgorithm {
    
    @Override
    public DistributionPlan generate(CigaretteBasicInfo basicInfo, Map<String, CustomerData> customerDataMap) {
        // 1. 获取该卷烟的投放区域
        List<String> deliveryAreas = parseDeliveryAreas(basicInfo.getDeliveryAreas());
        
        // 2. 计算总客户数
        int totalCustomers = deliveryAreas.stream()
            .mapToInt(area -> customerDataMap.getOrDefault(area, new CustomerData()).getCustomerCount())
            .sum();
        
        // 3. 根据客户数分布计算档位分配
        BigDecimal[] distribution = new BigDecimal[30];
        
        // 实现具体的分配算法逻辑
        for (int i = 0; i < 30; i++) {
            // 基于客户数、历史数据、业务规则等计算各档位分配值
            distribution[i] = calculatePositionValue(i + 1, totalCustomers, basicInfo);
        }
        
        // 4. 构建分配方案
        return DistributionPlan.builder()
            .cigCode(basicInfo.getCigCode())
            .cigName(basicInfo.getCigName())
            .deliveryAreas(basicInfo.getDeliveryAreas())
            .year(basicInfo.getYear())
            .month(basicInfo.getMonth())
            .weekSeq(basicInfo.getWeekSeq())
            .distribution(distribution)
            .generatedTime(LocalDateTime.now())
            .build();
    }
    
    private BigDecimal calculatePositionValue(int position, int totalCustomers, CigaretteBasicInfo basicInfo) {
        // 实现具体的档位值计算逻辑
        // 可以基于：
        // - 档位权重（高档位分配更多）
        // - 客户数量
        // - 卷烟类型
        // - 历史销售数据
        // - 市场策略等因素
        
        return BigDecimal.valueOf(/* 计算结果 */);
    }
}
```

### 3. 数据模型

#### 3.1 请求数据模型
```java
public class GeneratePlanRequest {
    private Integer year;
    private Integer month;
    private Integer weekSeq;
    
    // 构造函数、getter、setter省略...
}
```

#### 3.2 分配方案数据模型
```java
public class DistributionPlan {
    private String cigCode;
    private String cigName;
    private String deliveryAreas;
    private Integer year;
    private Integer month;
    private Integer weekSeq;
    private BigDecimal[] distribution; // 30个档位的分配值
    private LocalDateTime generatedTime;
    
    // 构造函数、getter、setter省略...
}
```

---

## 🔒 业务规则和约束

### 1. 数据依赖
- **必须先导入卷烟投放基本信息**：包含卷烟代码、名称、投放区域等
- **必须先导入区域客户数**：提供各投放区域的客户数量数据
- **时间范围一致性**：基本信息和客户数据必须在同一时间范围内

### 2. 算法约束
- **档位分配总和**：所有档位分配值总和应符合业务规则
- **区域平衡性**：多区域投放时要考虑区域间的平衡
- **历史数据参考**：可参考历史分配数据进行优化

### 3. 系统约束
- **并发控制**：同一时间范围内避免重复生成
- **数据完整性**：生成过程中确保数据一致性
- **性能考虑**：大批量卷烟生成时的性能优化

---

## ✅ 测试建议

### 1. 功能测试
- 测试完整流程：导入基本信息 → 导入客户数据 → 生成分配方案
- 验证生成的分配方案数据正确性
- 测试不同时间范围的方案生成

### 2. 边界测试
- 缺少基本信息时的处理
- 缺少客户数据时的处理
- 无效时间参数的处理

### 3. 性能测试
- 大量卷烟数据的生成性能
- 并发生成请求的处理
- 算法执行时间测试

---

## 🎉 功能完成总结

### ✅ 前端功能完成
1. **生成分配方案按钮** - 位于导入按钮区域，醒目的橙色警告样式
2. **时间选择对话框** - 直观的年月周选择界面
3. **智能状态管理** - 实时验证和状态提示
4. **结果反馈机制** - 详细的成功/失败信息反馈
5. **自动数据刷新** - 生成后自动更新表格显示

### 📋 后端接口设计
1. **完整接口规范** - 详细的请求响应格式定义
2. **业务逻辑设计** - 基于基本信息和客户数据的智能算法
3. **错误处理机制** - 全面的异常情况处理
4. **数据模型定义** - 清晰的数据结构和约束
5. **算法框架设计** - 可扩展的分配算法接口

该功能为卷烟投放管理系统提供了智能的分配方案生成能力，大大提高了工作效率，减少了人工计算错误，为业务决策提供了有力支持。

更新时间：2025年1月9日
